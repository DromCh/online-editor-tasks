# parseVersion

Розв'язання цієї задачі може виглядати ось так:

```js
const parseVersion = (dependencies = "") => {
  // 1. Якщо надана стрічка пуста, то повернути результат одразу
  if (dependencies.length == 0) {
    return { dependencies: {} };
  }
  const modules = {};
  const candidates = dependencies.split("\n");
  // 2. Інакше, для кожної версії кандидату для модуля
  candidates.forEach((candidate) => {
    const [module, version] = candidate.split("==").map((c) => c.trim());
    const [majorCandidate = 0, minorCandidate = 0, patchCandidate = 0] = version
      .split(".")
      .map((v) => parseInt(v, 10));
    const moduleVersion = `${majorCandidate}.${minorCandidate}.${patchCandidate}`;
    // 3. Запамʼятати її номер, якщо такого модуля ще не було
    if (!modules[module]) {
      modules[module] = moduleVersion;
    }
    const [majorTarget = 0, minorTarget = 0, patchTarget = 0] = modules[module]
      .split(".")
      .map(Number);
    // 4. Або ж запамʼятати його, якщо він більш новий
    if (
      majorCandidate >= majorTarget &&
      minorCandidate >= minorTarget &&
      patchCandidate >= patchTarget
    ) {
      modules[module] = moduleVersion;
    }
  });
  // 5. Повернути результат
  return { dependencies: modules };
};
```

Давайте розглянемо дане рішення. Першим кроком алгоритму є перевірка вхідної стрічки чи потрібно її обробляти, чи повернути результат одразу.

Якщо вхідні дані необхідно обробляти, то робимо перевірку на повторення версій модулів. Як видно, в порівнянні з текстовим форматом, використання JSON формату для залежностей дає перевагу в тому, що дуплікація модулів неможлива (якщо модулі додаються з використанням програми як, наприклад, `npm`).

Далі, для кожної версії кандидату для модуля ми розділяємо назву модуля і її версію, за допомогою методу `split`. При чому, ми прибираємо зайві відступи (бо згідно формату може бути один чи більше пробілів) за допомогою методу `trim`.

```js
const [module, version] = candidate.split("==").map((c) => c.trim());
```

Наступним кроком нам необхідно виділити кожний елемент версії і тут ми використовуємо дефолтне значення "0", бо, згідно умови, не кожний елемент версії має бути наданий. Це нам необхідно для того, щоб порівняти значення кандидату зі збереженим значенням елементу версії.

```js
const [majorCandidate = 0, minorCandidate = 0, patchCandidate = 0] = version
  .split(".")
  .map((v) => parseInt(v, 10));
```

Наступним кроком ми перевіряємо, чи такий модуль є серед збережений значень і зберігаємо значення, якщо такого ще не було.

Інакше ми беремо збережене значення і перетворюємо на цифри. Це ми робимо за допомогою методу `map`, в який передаємо вбудований метод `Number`, що парсить вхідне значення.

```js
const [majorTarget = 0, minorTarget = 0, patchTarget = 0] = modules[module]
  .split(".")
  map(Number);
```

Після цього, ми порівнюємо отримане значення: якщо і мажорний елемент, і мінорний елемент, і патч елемент більше або дорівнює збереженого значення, то - запамʼятати нове значення.

Останнім кроком - повернути результат.

В наданих тест-кейсах опущені варіанти, коли надана версія тільки одна і вона містить постфікс, або надано декілька версій і постфіксна є найсвіжішою і т.д. для простоти.
