# seoTest

У JavaScript є багато способів вирішити цю задачу, але ми розглянемо тільки 2 методи: з використанням `split` і через регулярні вирази.

Рішення, за допомогою методу `split` може виглядати ось так:

```js
const seoTest = (text = "", word = "") => {
  // 1. Якщо слово пусте або немає тексту - повернути 0
  if (text.trim() === "" || word.trim() === "") {
    return 0;
  }
  // 2. Інакше перевести текст і слово у нижній регістр
  const string = text.toLocaleLowerCase();
  const subString = word.toLocaleLowerCase();
  // 3. Порахувати скільки разів зустрічається слово у тексті
  const result = string.split(subString).length - 1;
  // 4. Повернути результат
  return result;
};
```

`split` — це метод JavaScript для поділу рядків на масив підрядків із збереженням оригінального рядка. Цей метод приймає роздільник і розділяє рядок на його основі. Ми використаємо один зручний прийом, щоб отримати кількість входжень підрядка в рядок. Ми встановимо підрядок як роздільник у методі `split`, таким чином ми можемо отримати кількість входжень підрядка з масиву, який повернув цей метод.

```js
"JavaScript, often abbreviated as JS, is a programming language.".split("Script")
// => ['Java', ', often abbreviated as JS, is a programming language.']
```

По суті, метод `split` видалив усі входження рядка "Script" із оригінального рядка та розрізав його в тих місцях, де було видалено підрядок. Оскільки ми знайшли один випадок рядка "Script", вихідний рядок було розрізано в одному місці, тому ми отримали два фрагменти. Ось чому нам потрібно відняти 1 від довжини масиву, коли ми обчислюємо кількість входжень підрядка.

Іншим методом підрахунку кількості входжень є використання регулярних виразів (RegEx). Це шаблони символів, які використовуються для пошуку, зіставлення та перевірки рядків. Використаємо це для підрахунку кількості входжень підрядка в рядок.

У JavaScript ми пишемо шаблон регулярного виразу між двома похилими рисками - `/pattern/`. За бажанням після другої похилої риски ви можете розмістити список прапорців — спеціальних символів, які використовуються для зміни типової поведінки під час зіставлення шаблонів.

- g - гарантує, що ми отримуємо всі входження шаблону (не лише перше)
- i - гарантує, що зіставлення не залежить від регістру

```js
"JavaScript, often abbreviated as JS, is a programming language.".match(/Script/gi)
// => ['Script']
```

Таким чином ми можемо вирішити нашу задачу наступним чином:

```js
const seoTest = (text = "", word = "") => {
  // 1. Якщо слово пусте або немає тексту - повернути 0
  if (text.trim() === "" || word.trim() === "") {
    return 0;
  }
  // 2. Інакше перевести текст і слово у нижній регістр
  const string = text.toLocaleLowerCase();
  const subString = word.toLocaleLowerCase();
  // 3. Порахувати скільки разів зустрічається слово у тексті
  const result = string.match(new RegExp(subString, "gi")).length;
  // 4. Повернути результат
  return result;
};
```

Щодо швидкодії, то метод `split` завжди буде працювати швидше, ніж метод регулярних виразів, хоча це не дуже помітно навіть для досить великих текстових фрагментів. Тому можете використовувати будь-який з цих підходів, той що виглядає більш зрозумілим.
