# revertArray

Розв'язання цієї задачі може виглядати ось так:

```js
export const revertArray = (arr = [], n = 0) => {
  return arr.reverse().slice(0, n);
};
```

## Алгоритм дій:

1) Розгорнути масив, переставляючи елементи в зворотньому порядку
2) Взяти тількі перші `n` елементів (чи весь масив, якщо `n` виявиться більше довжини масива)
3) Повернути отриманий масив

Давайте розглянемо кожен із цих вбудованих методів і подивимося як можна вирішити це завдання за допомогою циклів.

Для розгортання масиву в JavaScript існує вбудований метод `reverse`. Цей метод на місці переставляє елементи масиву, на якому він був викликаний, змінює масив та повертає посилання на нього.

**Обережно:** цей метод є деструктивним і змінює вихідний масив.

```js
export const revertArray = (arr = [], n = 0) => {
  const newArr = arr.reverse();
};
```

Цей метод можна реалізувати за допомогою цикла

```js
export const revertArray = (arr = [], n = 0) => {
  // Створюємо тимчасову змінну, де буде зберігаться розгорнутий масив
  const newArr = [];
  // За допомогою цикла перебираємо елементи масиву arr,
  // починаючи з останнього
  for (let i = arr.length - 1, j = 0; i >= 0; i--, j++) {
    newArr[j] = arr[i];
  }
  // Отриманий результат знаходиться у змінній newArr
};
```

Цикл `for` може оперувати декількома змінними, що і було використано в прикладі вище. Як видно, нам необхідно було створити тимчасовий масив, що зайняло додаткову памʼять, саме тому рекомендується використовувати вбудовані методи, якщо вони є. Вбудовані методи, в загальному випадку, використовують менше памʼяті та процюють швидше.

Теперь нам необхідно взяти тільки `n` перших елементів нового масиву `newArr`. Для отримання зрізу масиву в JavaScript існує вбудований метод
`slice`. Цей метод повертає новий масив, що містить копію частини вихідного масиву. Цей метод приймає два необовʼязкових аргументи: `begin` та `end`.

`begin` - Індекс (рахунок починається з нуля), яким починати витяг. Негативне значення вказує, що відлік починається з кінця послідовності. Виклик `slice(-2)` витягне два останні елементи послідовності. Якщо `begin` не визначений, `slice()` починає працювати з індексом 0.

`end` - Індекс (рахунок починається з нуля), яким закінчувати витяг. Метод `slice()` витягує елементи з індексом меншим за `end`. Виклик `slice(1, 4)` витягне елементи з другого по четвертий (елементи за індексами 1, 2 та 3).

```js
export const revertArray = (arr = [], n = 0) => {
  const newArr = arr.reverse();
  const sliceArr = newArr.slice(0, n);
  return sliceArr;
};
```

Реалізуємо цей метод для заданих умов задачі за допомогою циклу.

```js
export const revertArray = (arr = [], n = 0) => {
  // Створюємо розгорнутий масив
  const newArr = [];
  for (let i = arr.length - 1, j = 0; i >= 0; i--, j++) {
    newArr[j] = arr[i];
  }
  // Результат будемо записувати у нову змінну
  const res = [];
  // Отриманий результат обмежемо до n значень
  for (let i = 0; i < n; i++) {
    // Перевіряємо чи не вийшли ми за межі масиву
    if (i >= newArr.length) {
      break;
    }
    // Якщо ні, то додаємо новий елемент
    res.push(newArr[i]);
  }
  // І повертаємо отриманий результат
  return res;
};
```

Також обмежити довжину масиву можна змінюючи значення `length`. Але необхідно перевірити, що задане число `n` не є більшим за довжину масиву. Це можна зробити за допомогою метода `min` з вбудованого модуля `Math`.

Метод `Math.min()` повертає найменше з нуля чи більше чисел.

**Обережно:** Якщо хоча б один із аргументів не може бути перетворений на число, результатом буде `NaN`.

```js
export const revertArray = (arr = [], n = 0) => {
  // Створюємо розгорнутий масив
  const newArr = [];
  for (let i = arr.length - 1, j = 0; i >= 0; i--, j++) {
    newArr[j] = arr[i];
  }
  // Обмежуємо кількість елементів,
  const len = Math.min(newArr.length, n); // обираюче менше з двох
  newArr.length = len; // значень для довжини нового масиву
  return newArr;
};
```

А тепер розглянемо гіпотетичний випадок з високим навантаженням. Приведений нижче приклад (саме в наведених обмеженнях) в реальному проекті може не зустрітитсь, але подібна ситуація можлива.

Допустимо, необхідно відобразити невелику кількість елементів (наприклад 10) для дуже великого масиву (наприклад 100 тис. елементів). Припустимо, у нас є коментарі за 10 років (їх кількість постійно зростає) і вони не видаляються з часом. Ці коментарі знаходяться в базі даних, яка віддає всі значення разом, без можиловості прочитати тільки зріз (останні Х елементів). Тому оптимальним алгоритмом для таких умов буде:

1) В циклі від останнього елемента до `n` зберігати значення в новий масив
2) Повернути новий масив

тому що недоцільно розгортати всі 100 тис. елементів тільки для того, щоб отримати маленький зріз.

```js
export const revertArray = (arr = [], n = 0) => {
  // Результат будемо писати в тимчасову змінну
  const result = [];
  // В циклі від останнього елемента до `n`
  for (let i = arr.length - 1; i >= arr.length - n; i--) {
    // Зберігаємо значення в новий масив
    result.push(arr[i]);
  }
  // І повертаємо отриманий результат
  return result;
};
```

## Корисні посилання

[Array.prototype.reverse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse).

[Array.prototype.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)

[Array.prototype.push](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push)

[Math.min](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/min)

[NaN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/NaN)

[for loop](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for)

Про різницу між мутуючими та немутуючими методами масиву [JavaScript: Array, mutability & immutability](https://dev.to/lassiecoder/javascript-array-mutability-immutability-342a)
