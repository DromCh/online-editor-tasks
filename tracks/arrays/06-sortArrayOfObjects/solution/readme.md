# sortArrayOfObjects

Найпростіше розв'язання цієї задачі може виглядати ось так:

```js
const sortArrayOfObjects = (products = [], sortBy = "") => {
  const sortedProducts = products.sort(
    (product1, product2) => {
      if (sortBy === "asc") {
        return product1.rating - product2.rating;
      } else {
        return product2.rating - product1.rating;
      }
    }
  );

  return sortedProducts;
};
```

Давайте розглянемо, що тут відбувається і оптимізуємо це рішення.

Існує багато методів сортування (["бульбашкою"](https://uk.wikipedia.org/wiki/Сортування_бульбашкою), ["змішуванням"](https://uk.wikipedia.org/wiki/Сортування_змішуванням), ["швидке"](https://uk.wikipedia.org/wiki/Швидке_сортування) і т.д.), вони відрізняються швидкістю виконання, обʼємом використаної памʼяті і т.п. Ви можете реалізувати будь-який з цих алгоритмів за допомогою одного чи декільком циклів `for`. Але простіше всього це робити за допомогою вбудованого методу [sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort). Краще використати вбудований метод з декількох причин. По-перше, реалізація вбудованого методу виконана за допомогою самого інтерпретатора (у випадку "V8 JavaScript engine", то є C++), а якщо ви напишете власну імплементацію на JS, то її спочатку потрібно транслювати у низькорівневий код і потім виконати. По-друге, розробники JS engine постійно слідкують за сучасним розвитком Computer Science і оновлюють вбудований алгоритм сортування, щоб він був оптимальним з точки зори швидкості і використання памʼяті.

Для початку нам необхідно для кожної пари продуктів зробити перевірку. Для цього ми використовуємо метод `sort`. Цей метод сортує елементи масиву на місці та повертає посилання на той самий масив, тепер відсортований. Порядок сортування за замовчуванням – за зростанням.

```js
sortedProducts = products.sort(
  // ...
);
```

Але якщо на вхід ми подаємо не примітивне значення, а обʼєкт, то необхідно також подати на вхід функцію, яка підкаже вбудованому алгоритму, по якій ознаці необхідно порівнювати два елементи. Тому наступний крок звучить так: "Порівняти поле `rating` між собою". Що ми і робимо.

```js
const sortedProducts = products.sort(
    (product1, product2) => {
      return product1.rating - product2.rating;
    }
```

В цьому випадку ми сортуємо елементи масиву по зростанню, тобто від меншого значення, до більшого. Ми використовуємо математичну операцію віднімання з наступної причини. Функція-компаратор, завжди має повертати 1, 0 або -1. Для `compare(a, b)` має бути:

- якщо `a` менше `b` за деяким критерієм упорядкування - повернути "-1"
- якщо `a` більше `b` за критерієм упорядкування - повернути "1"
- якщо `a` дорівнює `b` - повернути "0"

Але нам необхідно враховувати і наступне: "Змінити позицію пари згідно заданого значення `sortBy`". Таким чином ми додаємо перевірку до нашої програми. Якщо аргумент `sortBy` дорівнює "asc", то необхідно від першого рейтингу відняти другий і навпаки.

```js
if (sortBy === "asc") {
  return product1.rating - product2.rating;
} else {
  return product2.rating - product1.rating;
}
```

І нам залишився останній крок - повернути отриманий масив продуктів, що ми й робимо:

```js
return sortedProducts;
```
